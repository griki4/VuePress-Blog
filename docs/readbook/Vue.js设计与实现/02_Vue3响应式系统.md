---
title: 《Vue.js设计与实现》第二章读书笔记
---

## 响应式系统的作用与实现

`Vue3`的响应式系统的实现核心就是就是两点。
- 依赖收集
- 派发更新

依赖收集是在读取数据阶段发生的。假如一个`effect`函数读取了某一个对象的属性，通过给这个对象设置`Proxy`
代理并且设置`getter`配置，可以知道这个函数并且将它收集到某个地方。也就是依赖收集。

派发更新是指当对象的某个属性发生变化时（通过`Proxy`设置`setter`选项来实现属性值变化监听），将这个属性收集到的依赖（`effect`函数）取出来依次执行。
执行时这些函数会读取新的属性值并执行相应操作，也就是派发更新操作。

具体`Vue`中关于实现依赖收集的数据结构如下所示：
![响应式数据结构](../../assets/reactive.png)
简单解释一下这个结构。首先有一个`WeakMap`，它的`key`是`target`，`target`是我们代理的对象，比如
`Proxy`代理`data`的时候，`data`里面可能有很多对象，`target`代表的就是他们。

**使用`WeakMap`的原因是，弱引用的特性可以做到`target`不再被引用时能够正确的被垃圾回收机制回收。**
毕竟如果原对象都不存在了，那么对于原对象的代理自然也没有必要了。

然后是每个`target`的值，是对象的每个属性，也就是图中的`key`。`key`的值是一个`Set`结构，类似数组，这个里面就是响应式的主角，
被作为依赖收集的`effect`函数。

**之所以每个`key`都需要有自己的`Set`是因为希望能够准确定位哪一个属性发生了变化。而不是把所有属性的
`effect`函数都取出来执行，这显示不是明智的做法。**

## 及时清除无效依赖

上述通过`Proxy`的`getter`和`setter`实现的响应式系统看上去比较完善了，但是还存在一个问题。
比如一个`effect`函数在后续的使用过程中，原先可能读取了一个属性，但是后续又不读取了，例如：
```javascript
const data = { ok: true, text: 'hello world' }
const obj = new Proxy(data, { /* ... */ })

effect(function effectFn() {
    document.body.innerText = obj.ok ? obj.text : 'not'
})
```
`ok`属性如果变为`false`则`effectFn`就不会读取`obj.text`属性了，但是之前他已经作为依赖被收集
到了`obj.text`的依赖中。后续`obj.text`属性变换还是会引起`effectFn`函数执行，这是不必要的性能消耗。
解决这个问题的方法是：
**每次执行`effect`函数之前，把它从所有的集合中先移除然后在执行。**
因为`effect`重新执行时又会读取新数据，重新触发依赖收集。同时还可以保证那些无效的依赖可以即使被清除。

要做到这一点，在`effect`函数当中我们也需要知道，它被作为依赖收集到了哪些`key`的依赖集合中。所以在`Proxy`
收集依赖时，除了将`effect`函数收集起来，还应该调用每个`effect`中的某个方法，将依赖集合自身添加到`effect`
函数中保存依赖集合的数据结构。

添加了无效依赖清除功能之后，响应式系统的简易代码如下：
```javascript
//全局的WeakMap
const bucket = new WeakMap()

//设置代理
const obj = new Proxy(data, {
    get(target, key){
        //activeEffect就是存储effect函数的临时变量
        //effect函数内部首先会进行一个清除操作，然后执行真正的副作用函数。
        if(!activeEffect) return target[key] 
        let depsMap = bucket[target]
        //没有target代理
        if(!depsMap) {
            bucket.set(target, (depsMap = new Map()))
        }
        //定位属性
        let deps = depsMap.get(key)
        if(!deps) {
            deps.set(key, (deps = new Set()))
        }
        //收集依赖
        deps.add(activeEffect)
        //在effect函数的deps中添加当前的deps
        activeEffect.deps.push(deps)
        return target[key]
    },
    set(target, key, newVal){
        //修改属性值
        target[key] = newVal
        //取出effect函数依次执行
        const depsMap = bucket.get(target)
        if(!depsMap) return
        const effects = depsMap.get(key)
        effects && effects.forEach(fn => fn())
    }
})
```
这里也简单贴一下`activeEffect`的代码
```javascript
let activeEffect
function effect(fn) {
    const effectFn = () => {
        //cleanup从依赖中清除自己
        cleanup()
        activeEffect = effectFn
        fn()
    }
    //存储deps的数据结构
    effectFn.deps = []
    effectFn()
}

function cleanup () {
    for (let i = 0; i < effectFn.deps.length; i++) {
        // deps 是依赖集合
        const deps = effectFn.deps[i]
        // 将 effectFn 从依赖集合中移除
        deps.delete(effectFn)
        }
    // 最后需要重置 effectFn.deps 数组
    effectFn.deps.length = 0
}
```
总结就是：`deps`和`effect`两者是相互知根知底的。`deps`知道自己收集了哪些依赖，`effect`也知道自己被
哪些`deps`当做依赖收集了。
