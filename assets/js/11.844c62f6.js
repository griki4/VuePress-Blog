(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{448:function(t,a,s){t.exports=s.p+"assets/img/Request_Memoization.5dd3b1ef.png"},449:function(t,a,s){t.exports=s.p+"assets/img/data_cache.a897d9f7.png"},513:function(t,a,s){"use strict";s.r(a);var e=s(2),n=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("为了提高页面的性能，减少资源消耗，Next.js会尽可能多的对页面数据进行缓存，在客户端和服务端都会进行缓存，以下是几种缓存策略。")]),t._v(" "),a("h2",{attrs:{id:"request-memorization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#request-memorization"}},[t._v("#")]),t._v(" Request Memorization")]),t._v(" "),a("p",[t._v("Next.js推荐在需要数据的地方请求数据，而不是在父组件中请求数据然后传递给子组件。看起来前者会引起更多的重复请求而导致页面性能下降，但是Next.js采用React的Request Memoization解决了这个问题。\n简单来说，在页面渲染的过程中，如果多次请求了同一个接口，最终只会有一个请求引起服务端的数据库操作，操作的结果会被缓存在服务端。\n即第一个请求会执行正常流程，服务端会访问数据库获取请求需要的数据并返回，这个返回的结果会被缓存，下次再请求同样的接口时返回的就是缓存数据，而不需要再访问数据库。如下如所示：\n"),a("img",{attrs:{src:s(448),alt:"Request Memoization"}})]),t._v(" "),a("p",[t._v("Request Memoization的存在提供了更加符合开发者习惯的便利，"),a("strong",[t._v("在需要数据的地方请求数据")]),t._v("，同时又不用担心由于多次重复请求导致的性能问题。如果不想使用这个特性，可使用下面的方式编写"),a("code",[t._v("fetch")]),t._v("请求。")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" signal "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbortController")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fetch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("url"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" signal "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("两点注意事项：")]),t._v(" "),a("ol",[a("li",[t._v("该特性仅在使用"),a("code",[t._v("fecth")]),t._v("方法进行"),a("code",[t._v("GET")]),t._v("类型的请求时才会生效。")]),t._v(" "),a("li",[t._v("只有在React的组件树中才会生效。")])]),t._v(" "),a("h2",{attrs:{id:"data-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-cache"}},[t._v("#")]),t._v(" Data Cache")]),t._v(" "),a("p",[t._v("Data Cache是一种在服务端缓存数据的机制，目的是减少到达数据源（比如数据库）的请求数量。下图是Data Cache的工作原理:\n"),a("img",{attrs:{src:s(449),alt:"Data Cache"}})]),t._v(" "),a("p",[t._v("虽然Request Memoization和Data Cache都是通过利用缓存数据来减少请求数量的，但是Request Memoization是通过缓存请求函数的返回结果的，这只会在请求期间持续。\n而Data Cache的生命周期是持续于应用部署期间的，它减少的是对于数据源的访问次数。")]),t._v(" "),a("p",[t._v("使用以下方式可以绕过Data Cache")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fetch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'url'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("cache"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'no-store'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("h2",{attrs:{id:"full-route-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#full-route-cache"}},[t._v("#")]),t._v(" Full Route Cache")]),t._v(" "),a("p",[t._v("Full Route Cache发生在Next.js进行页面渲染的过程，主要是将生成的HTML和RSC Payload缓存在服务端。回顾一下Next.js的渲染流程：")]),t._v(" "),a("ol",[a("li",[t._v("Next.js将React Server Component转换为一种特殊的数据形式RSC Payload。")]),t._v(" "),a("li",[t._v("结合RSC Payload和客户端JS，在服务端生成页面的HTML。")]),t._v(" "),a("li",[t._v("将HTML和RSC Payload发往客户端，用户会立刻看到一个不具备交互功能的静态页面。")]),t._v(" "),a("li",[t._v("RSC Payload协调客户端和服务端组件树，更新DOM。")]),t._v(" "),a("li",[t._v("执行hydration流程，让页面具备交互能力。")])]),t._v(" "),a("p",[t._v("Full Route Cache发生在第2步到第3步之间。在生成页面HTML和RSC Payload之后，Next.js会将两者缓存在服务端，这样当用户下一次访问该页面或者其他用户访问这个页面的时候，\n直接将缓存的HTML和RSC Payload发送给客户端即可，能够节省1，2两步所花费的时间。")]),t._v(" "),a("p",[a("strong",[t._v("注意，Full Route Cache仅针对静态渲染的页面生效，对于使用了类似"),a("code",[t._v("cookies()")]),t._v(","),a("code",[t._v("headers()")]),t._v("的动态函数或者"),a("code",[t._v("export const dynamic = 'force-dynamic'")]),t._v("这样的动态渲染命令的页面而言并不生效。")]),t._v("\n因为这些页面出于某些原因需要将实时数据展示给用户，所以每次请求都会重新进行构建，以确保页面展示的数据出于最新状态。")]),t._v(" "),a("h2",{attrs:{id:"router-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#router-cache"}},[t._v("#")]),t._v(" Router Cache")]),t._v(" "),a("p",[t._v("Router Cache是一项在客户端的缓存策略，维持用户会话期间的页面数据，缓存的数据就是RSC Payload。")]),t._v(" "),a("p",[t._v("一个常见的场景，用户会经常在页面中进行路由的跳转，主要是前进和后退，用户每一次前进和后退都向服务端请求数据会造成极大的性能浪费。所以Next.js对于用户访问过的路由都会进行缓存，这个缓存是客户端缓存，\n"),a("strong",[t._v("无论是静态还是动态页面，Router Cache都会生效")]),t._v("，这是和Full Route Cache最大的不同点。")])])}),[],!1,null,null,null);a.default=n.exports}}]);